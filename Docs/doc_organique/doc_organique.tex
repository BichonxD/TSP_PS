\documentclass{article}

% Mise en page
\usepackage[scale=0.75]{geometry}
% Pied de page
\usepackage{fancyhdr}
\pagestyle{fancy}
\renewcommand{\headrulewidth}{0pt}
% Interligne après les paragraphes
\setlength{\parskip}{1.5ex}

% Langues
\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{eurosym}

% Images
\usepackage{graphicx}
\usepackage{rotating}

% Code source
\usepackage{listings}
\usepackage{color}

\newcommand{\code}[1]{\lstinputlisting[title=#1.java]{../src/#1.java}}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{
  frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  stepnumber=5,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true
  tabsize=4,
  literate=
    {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
    {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
    {à}{{\`a}}1 {è}{{\'e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ò}{{\`u}}1
    {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ò}{{\`U}}1
    {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
    {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
    {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
    {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
    {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
    {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
    {€}{{\euro{}}}1 {£}{{\pounds}}1
}


\begin{document}

\input{page_de_garde.tex}

\rhead{Programmation Stochastique - Document organique}
\lfoot{\includegraphics[scale=0.3]{../polytech.jpg}}
\rfoot{BOSOM - CHAUSSY}

\section{Note}

Pour inclure un fichier avec coloration syntaxique de la forme :\newline
../src/nomDuFichier.java\newline
utiliser le code suivant en commentaire dans le fichier
%\code{nomDuFichier}

\section{Présentation générale de la structure du programme}

Pour ce projet nous avons repris comme base le projet codé pour la Programmation en Nombre Entier. Néanmoins, nous avons eu beaucoup de modifications a effectuer car nous n'avions pas implémenté le recuit simulé et que nous ne gérions que la lecture des fichiers ".tsp" et formattés selon le format EUC_2D.
Nous avons donc modifié notre programme de façon à ce que nous puissions lire les fichiers ".xml" tout en gardant la compatibilité avec les fichiers ".tsp" formattés au format EUC_2D ou CEIL_2D (la différence entre les deux formats étant minime).
Voici notre code sous forme de diagramme UML.

\section{GestionFichierTSP}

Cette classe permet de lire un fichier ".tsp". Elle contient uniquement une méthode statique qui à partir du nom de fichier donné en paramètre renvoie une arraylist du type Ville. Si il y a une erreur l'arraylist renvoyée est vide.
Les fichiers lu doivent être formatés selon le format de données de la TSPLIB et le jeu de donnée doit être au format EUC_2D ou CEIL_2D.

\section{GestionFichierXML}

Cette classe permet de lire un fichier ".xml". Elle contient uniquement une méthode statique qui à partir du nom de fichier donné en paramètre renvoie une matrice d'Integer. Si il y a une erreur la matrice renvoyée est vide.
Les fichiers lu doivent être formatés selon le format de données de la TSPLIB.

\section{Ville}

Cette classe permet de stocker une ville pour les fichiers ".tsp". Elle comprend des méthodes d'accès à ces différents éléments et une fonction pour calculer la distance entre elle-même et une ville voisine.

\section{CycleHamTSP}

Cette classe permet de construire et d'optimiser un cycle Hamiltonien.
Elle appelle la méthode statique fournie par GestionFichierTSP pour lire le document voulu et initialise le cycle hamiltonien.
Elle contient trois méthodes pour former un cycle hamiltonien de base :
\begin{itemize}
\item{Le Plus Proche Voisin (PPV)}{Cette méthode donne un cycle hamiltonien de base en reliant le point actuellement étudié à son plus proche voisin.}
\item{La Plus Proche Insertion (PPI)}{Cette méthode part d'un cycle hamiltonnien constitué du point défini comme départ et son plus proche voisin. Elle ajoute au fur et à mesure tous les points ne faisant pas partie du cycle à celui-ci en trouvant le point le plus proche appartenant au cycle.}
\item{Le Plus Proche Voisin Threadé (PPVT)}{Cette méthode est exactement la même que celle du Plus Proche Voisin à la différence que pour trouver le plus proche voisin du point étudié nous utilisons deux threads. Cela permet de gagner du temps d'execution sur les grosses instances telles que celle de Mona Lisa. C'est cette méthode que nous utilisons par défault.}
\end{itemize}
Cette classe permet aussi d'optimiser un cycle hamiltonien via l'algorithme du recuit simulé. Le calcul de la température est automatique. Nous utilisons un algorithme proche de celui du 2-opt pour tourver une solution voisine.

\section{CycleHamXML}

Cette classe, tout comme la classe CycleHamTSP, permet de construire et d'optimiser un cycle Hamiltonien.
Elle appelle la méthode statique fournie par GestionFichierXML pour lire le document voulu et initialise le cycle hamiltonien.
À la différence de CycleHamTSP elle ne contient que deux méthodes pour former un cycle hamiltonien de base :
\begin{itemize}
\item{Le Plus Proche Voisin (PPV)}{Cette méthode donne un cycle hamiltonien de base en reliant le point actuellement étudié à son plus proche voisin. Nous utilisons cette méthode par défault.}
\item{La Plus Proche Insertion (PPI)}{Cette méthode part d'un cycle hamiltonnien constitué du point défini comme départ et son plus proche voisin. Elle ajoute au fur et à mesure tous les points ne faisant pas partie du cycle à celui-ci en trouvant le point le plus proche appartenant au cycle.}
\end{itemize}
Cette classe permet aussi d'optimiser un cycle hamiltonien via l'algorithme du recuit simulé. Le calcul de la température est automatique. Nous utilisons un algorithme proche de celui du 2-opt pour tourver une solution voisine.

\section{Thread_ParcoursArrayVille}

Cette classe a pour simple objectif la parallelisation de la recherche du plus proche voisin d'un point. Elle sert uniquement à l'algorithme du Plus Proche Voisin Threadé de la classe CycleHamTSP. Elle hérite de la classe Thread.

\section{DessinTSP}

Une fois le cycle construit il est agréable de voir le dessin obtenue par nos algorithmes. Cette classe a pour objectif de dessiner le cycle hamiltonien obtenue pour les fichiers ".tsp". Elle hérite de la classe JFrame puis appelle la classe CanvasTSP pour dessiner le cycle.

\section{CanvasTSP}

Cette classe dessine le cycle hamiltonien donné en paramètre. Elle hérite de la classe JPanel.

\section{Tsp_ps}

Cette classe contient le main. Elle gère les options que nous avons implémentées et qui sont décrites dans le document d'utilisateur. Elle permet, entre autre, de spécifier des options pour tester l'influence des paramètres sur le recuit simulé, de comparer des fichiers entre eux et de tester si les fichiers peuvent être lus.

\end{document}
